import mujoco
import os
import xml.etree.ElementTree as ET
import math

"""
This script exports a MuJoCo MJCF model from a URDF file.
It modifies the MJCF to include a floor, lighting, a floating base, and actuators.
It also rewrites mesh file paths to ensure they are correctly referenced.

TODO: Need to solve the path issue for the mesh files.

Usage:
    python export_mj_model.py
"""

def export_mj_model(input_urdf, output_mjcf):
    """
    Exports and modifies a MuJoCo MJCF model from a URDF file.
    Adds floor, lighting, floating base, and actuators.
    """
    # Convert URDF to MJCF
    model = mujoco.MjModel.from_xml_path(input_urdf)
    mujoco.mj_saveLastXML(output_mjcf, model)

    # Load MJCF XML for editing
    tree = ET.parse(output_mjcf)
    root = tree.getroot()

    # Add autogenerated comment
    header = [
      "==============================================================",
      " This MJCF model is autogenerated from a URDF file.",
      " It is not recommended to modify this file directly.",
      "=============================================================="
    ]
    for i, line in enumerate(header):
      comment = ET.Comment(line)
      comment.tail = "\n"
      root.insert(i, comment)

    # Rewrite mesh file paths
    asset = root.find("asset")
    if asset is not None:
        for mesh in asset.findall("mesh"):
            old_file = mesh.get("file")
            if old_file and (old_file.endswith(".STL") or old_file.endswith(".stl")):
                new_path = f"../urdf/{old_file}"
                mesh.set("file", new_path)

    # Rewrite option (make if not exist)
    option = root.find("option")
    if option is None:
        option = ET.SubElement(root, "option")
    option.set("integrator", "RK4")  # Set integrator to RK4
    option.set("timestep", "0.002")  # Set timestep to 0.002 seconds
    option.set("gravity", "0 0 -9.8")  # Set gravity to Earth's gravity

    # Remake body structure
    worldbody = root.find("worldbody")
    if worldbody is not None:
        # Add floor
        ET.SubElement(worldbody, "geom", {
            "name": "floor",
            "type": "plane",
            "pos": "0 0 0",
            "size": "5 5 0.1",
            "rgba": "0.8 0.9 0.8 1",
            "contype": "1",
            "conaffinity": "1",
            "friction": "0.0 0.0 0.0",
            "solref": "0.01 1",
            "solimp": "0.9 0.95 0.001"
        })

        # Add light
        ET.SubElement(worldbody, "light", {
            "name": "main_light",
            "pos": "0 0 3",
            "dir": "0 0 -1",
            "diffuse": "1 1 1",
            "specular": "0.3 0.3 0.3"
        })

        # Add mocap body
        mocap_body = ET.SubElement(worldbody, "body", {
            "mocap": "true",
            "name": "mocap",
            "pos": "0.1 0.1 0.1"
        })
        ET.SubElement(mocap_body, "site", {
            "pos": "0 0 0.075",
            "size": "0.003 0.003 0.1",
            "type": "box",
            "name": "mocap_left_site1",
            "rgba": "0 0 1 1"
        })
        ET.SubElement(mocap_body, "site", {
            "pos": "0 0.075 0",
            "size": "0.003 0.1 0.003",
            "type": "box",
            "name": "mocap_left_site2",
            "rgba": "0 1 0 1"
        })
        ET.SubElement(mocap_body, "site", {
            "pos": "0.075 0 0",
            "size": "0.1 0.003 0.003",
            "type": "box",
            "name": "mocap_left_site3",
            "rgba": "1 0 0 1"
        })
    
    # Add thrusters to the base body
    thrust_num = 8
    first_body = worldbody.find("body")
    if first_body is not None:
        # Rewrite contact parameters
        geom = first_body.find("geom")
        if geom is not None:
            geom.set("friction", "0.0 0.0 0.0")
            geom.set("solref", "0.01 1")
            geom.set("solimp", "0.9 0.95 0.001")


        # Add site to put thrusters
        # Place at each corner of the base body
        # Actuate into the direction of the circle
        thrust_distance = 0.2 * math.sqrt(2) - 0.044  # Distance from the center of the base body
        edge_num = 4
        z = 0.3  # Height of the thruster sites above the base
        for i in range(thrust_num):
            angle = (i // 2) * (360 / edge_num)
            x = thrust_distance * math.cos(angle * math.pi / 180)
            y = thrust_distance * math.sin(angle * math.pi / 180)
            # Flip the thrusters next to each other
            if i % 2 == 1:
                angle += 180
            site_name = f"thruster_{i+1}"
            ET.SubElement(first_body, "site", {
              "name": site_name,
              "pos": f"{x} {y} {z}",
              "quat": f"{math.cos(angle * math.pi / 360)} {0} {0} {math.sin(angle * math.pi / 360)}",  # Quaternion for rotation
              "size": "0.02 0.04 0.01",
              "type": "box",
              "rgba": "1 0 0 0.8",  # Red color for visibility
            })

            # TODO: Add new line for visibility

    
    # Add actuators to sites
    actuators = root.find("actuator")
    if actuators is None:
        actuators = ET.SubElement(root, "actuator")
    for i in range(thrust_num):
        actuator_name = f"thruster_{i+1}"
        ET.SubElement(actuators, "general", {
            "name": actuator_name,
            "site": f"thruster_{i+1}",
            "ctrlrange": "0 1",
            "gear": "0 1",
        })

    # Add actuator for each joint
    for joint in root.findall(".//joint"):
        if joint.get("name") and joint.get("type") != "free":
            actuator_name = f"{joint.get('name')}_actuator"
            ET.SubElement(actuators, "motor", {
                "name": actuator_name,
                "joint": joint.get("name"),
                "ctrlrange": "-1 1",
            })

    # Save the modified MJCF
    tree.write(output_mjcf)
    print(f"Modified MJCF model saved to {output_mjcf}")


if __name__ == "__main__":
    current_path = __file__.replace("export_mj_model.py", "")
    
    input_urdf = os.path.join(current_path, "..", "urdf", "pingu.urdf")
    output_mjcf = os.path.join(current_path, "pingu.xml")

    export_mj_model(input_urdf, output_mjcf)
    print(f"Exported MJCF model to {output_mjcf}")